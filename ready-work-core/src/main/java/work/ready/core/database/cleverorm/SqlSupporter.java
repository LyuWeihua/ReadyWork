/** * * Copyright (c) 2020 WeiHua Lyu [ready.work] * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package work.ready.core.database.cleverorm;import net.sf.jsqlparser.expression.Expression;import net.sf.jsqlparser.expression.Function;import net.sf.jsqlparser.expression.LongValue;import net.sf.jsqlparser.expression.operators.relational.ExpressionList;import net.sf.jsqlparser.statement.select.PlainSelect;import net.sf.jsqlparser.statement.select.SelectExpressionItem;import work.ready.core.database.ModelService;import work.ready.core.database.Page;import work.ready.core.tools.ClassUtil;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.regex.Matcher;

public interface SqlSupporter {    String syntaxCheck(AutoCodeGenerator holder, String sql);    String generate(AutoCodeGenerator holder);    default Map<String, String> sqlParameterProcess(AutoCodeGenerator holder){        boolean withCollection = false;        boolean withWhereOrderGroupCondition = false;        List<Integer> whereParamMap = new ArrayList<>();        List<Integer> orderByParamMap = new ArrayList<>();        List<Integer> groupByParamMap = new ArrayList<>();        Matcher matcher = ModelService.sqlPlaceHolderPattern.matcher(holder.realSql);        int p = holder.returnType.equals(Page.class) ? 2 : 0;        while (matcher.find()){            if(matcher.group().toLowerCase().contains("where")){                if(!String.class.equals(holder.parameters[p].getType())){                    throw new RuntimeException("CleverORM: Incompatible method parameters, parameter for sql WHERE condition should be String type, on " + ClassUtil.getMethodSignature(holder.method));                }                withWhereOrderGroupCondition = true;                whereParamMap.add(p);            } else if(matcher.group().toLowerCase().contains("order")){                if(!String.class.equals(holder.parameters[p].getType())){                    throw new RuntimeException("CleverORM: Incompatible method parameters, parameter for sql ORDER BY condition should be String type, on " + ClassUtil.getMethodSignature(holder.method));                }                withWhereOrderGroupCondition = true;                orderByParamMap.add(p);            } else if(matcher.group().toLowerCase().contains("group")){                if(!String.class.equals(holder.parameters[p].getType())){                    throw new RuntimeException("CleverORM: Incompatible method parameters, parameter for sql GROUP BY condition should be String type, on " + ClassUtil.getMethodSignature(holder.method));                }                withWhereOrderGroupCondition = true;                groupByParamMap.add(p);            }            p++;        }        String code = "String sql = \"" + holder.realSql + "\";\n";        String countTotalSql = "";        if(holder.returnType.equals(Page.class)) {                        PlainSelect mainSelect = (PlainSelect)(holder.selectStatement).getSelectBody();            mainSelect.setOrderByElements(null);            mainSelect.getSelectItems().clear();            Function function = new Function();            function.setName("COUNT");            List<Expression> expressions = new ArrayList<>();            LongValue longValue = new LongValue(1);            ExpressionList expressionList = new ExpressionList();            expressions.add(longValue);            expressionList.setExpressions(expressions);            function.setParameters(expressionList);            mainSelect.getSelectItems().add(new SelectExpressionItem(function));            countTotalSql = mainSelect.toString();            code += "String countTotalSql = \"" + countTotalSql + "\";\n";            code += "Matcher countSqlMatcher = sqlPlaceHolderPattern.matcher(countTotalSql);\n";        }        code += "List<Object> params = new ArrayList<>();\n" +                "Matcher sqlMatcher = sqlPlaceHolderPattern.matcher(sql);\n" +                "String[] placeHolder = new String[" + holder.parameters.length + "];\n";        for(int i = 0; i < holder.parameters.length; i++) {            if(holder.returnType.equals(Page.class) && i < 2) continue;              String pi = "p" + i;            if(ClassUtil.isSimpleType(holder.parameters[i].getType())) {                if(whereParamMap.contains(i)){                    code += "placeHolder[" + i + "] = \" WHERE \" + "+ pi +";\n";                } else if(orderByParamMap.contains(i)){                    code += "placeHolder[" + i + "] = \" ORDER BY \" + " + pi + ";\n";                } else if(groupByParamMap.contains(i)){                    code += "placeHolder[" + i + "] = \" GROUP BY \" + " + pi + ";\n";                } else {                    code += "placeHolder[" + i + "] = \" ? \";\n" +                            "params.add(" + pi + ");\n";                }            } else if(holder.parameters[i].getType().getComponentType() != null) {                withCollection = true;                code += "placeHolder[" + i + "] = \"\";\n" +                        "for(int j = 0; j < " + pi + ".length; j++){\n";                if(!ClassUtil.isBasicType(holder.parameters[i].getType().getComponentType())) {                    code += "   if(" + pi + "[j] == null) continue;\n";                }                code +=                        "   params.add(" + pi + "[j]);\n" +                        "   placeHolder[" + i + "] += (placeHolder[" + i + "].isEmpty()) ? \"?\" : \", ?\";\n" +                        "}\n" +                        "placeHolder[" + i + "] = \"(\" + placeHolder[" + i + "] + \")\";\n";            } else if(holder.parameters[i].getType().equals(List.class)) {                withCollection = true;                code += "placeHolder[" + i + "] = \"\";\n" +                        "for(int j = 0; j < " + pi + ".size(); j++){\n" +                        "   if(" + pi + ".get(j) == null) continue;\n" +                        "   params.add(" + pi + ".get(j));\n" +                        "   placeHolder[" + i + "] += (placeHolder[" + i + "].isEmpty()) ? \"?\" : \", ?\";\n" +                        "}\n" +                        "placeHolder[" + i + "] = \"(\" + placeHolder[" + i + "] + \")\";\n";            }        }        code += "StringBuffer sb = new StringBuffer();\n";        code += holder.returnType.equals(Page.class) ? "int i = 2;\n" : "int i = 0;\n";        code += "while(sqlMatcher.find()){\n" +                "   sqlMatcher.appendReplacement(sb, placeHolder[i]);\n" +                "   i++;\n" +                "}\n";        code += "sql = sqlMatcher.appendTail(sb).toString();\n";        if (holder.returnType.equals(Page.class)) {            code += "StringBuffer sb1 = new StringBuffer();\n" +                    "int j = 2;\n" +                    "while(countSqlMatcher.find()){\n" +                    "   countSqlMatcher.appendReplacement(sb1, placeHolder[j]);\n" +                    "   j++;\n" +                    "}\n";            code += "countTotalSql = countSqlMatcher.appendTail(sb1).toString();\n";        }        Map<String, String> result = new HashMap<>();        if (withCollection || withWhereOrderGroupCondition) {            holder.addClassImport(Matcher.class);            holder.addClassImport(ArrayList.class);            code += "Object[] paramArray = params.toArray();\n";            result.put("code", code);        } else {                        code = "String sql = \"" + holder.realSql + "\";\n";            if(holder.returnType.equals(Page.class)) {                if(holder.parameters.length > 2) {                    code += "Object[] paramArray = new Object[" + (holder.parameters.length - 2) + "];\n";                    for (int i = 2; i < holder.parameters.length; i++) {                        code += "paramArray[" + (i - 2) + "] = p" + i + ";\n";                    }                } else {                    code += "Object[] paramArray = new Object[0];\n";                }                code += "String countTotalSql = \"" + countTotalSql + "\";\n";            } else {                code += "Object[] paramArray = new Object[" + holder.parameters.length + "];\n";                for(int i = 0; i < holder.parameters.length; i++) {                    code += "paramArray[" + i + "] = p" + i + ";\n";                }            }            result.put("code", code);        }        result.put("audit", ".audit(\"" + holder.modelServiceClass.getName() + "\",\"" + ClassUtil.getMethodSignature(holder.method, false) + "\")");        return result;    }}